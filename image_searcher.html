<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ” CSVç”»åƒæ¤œç´¢&è‡ªå‹•ä¿å­˜ãƒ„ãƒ¼ãƒ«</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
        }

        .header p {
            color: #6c757d;
            font-size: 1.1rem;
        }

        .main-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        .upload-section {
            text-align: center;
            padding: 40px;
            border: 2px dashed #667eea;
            border-radius: 15px;
            background: rgba(102, 126, 234, 0.05);
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            background: rgba(102, 126, 234, 0.1);
            border-color: #764ba2;
            transform: translateY(-2px);
        }

        .upload-section.dragover {
            background: rgba(102, 126, 234, 0.2);
            border-color: #764ba2;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4rem;
            color: #667eea;
            margin-bottom: 20px;
        }

        .file-input {
            display: none;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545, #e83e8c);
            color: white;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .setting-item {
            background: rgba(102, 126, 234, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .setting-label {
            font-weight: 600;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .form-input {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-select {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
            background: white;
            cursor: pointer;
        }

        .progress-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
            display: none;
        }

        .progress-bar {
            background: #e9ecef;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            text-align: center;
            font-weight: 600;
            color: #2c3e50;
        }

        .log-section {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }

        .log-success {
            color: #28a745;
        }

        .log-error {
            color: #dc3545;
        }

        .log-info {
            color: #17a2b8;
        }

        .log-warning {
            color: #ffc107;
        }

        .csv-preview {
            background: rgba(102, 126, 234, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }

        .csv-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .csv-table th,
        .csv-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }

        .csv-table th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        .csv-table tr:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .results-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .result-item {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
            transition: transform 0.3s ease;
        }

        .result-item:hover {
            transform: translateY(-5px);
        }

        .result-image {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .result-name {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .result-status {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 500;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #6c757d;
        }

        /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .processing {
            animation: pulse 2s infinite;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in {
            animation: slideIn 0.5s ease-out;
        }

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .settings-grid {
                grid-template-columns: 1fr;
            }

            .results-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” CSVç”»åƒæ¤œç´¢&è‡ªå‹•ä¿å­˜ãƒ„ãƒ¼ãƒ«</h1>
            <p>CSVãƒ•ã‚¡ã‚¤ãƒ«ã®Aåˆ—ã®æ–‡å­—ã§ç”»åƒã‚’æ¤œç´¢ã—ã€è‡ªå‹•çš„ã«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ»ä¿å­˜ã—ã¾ã™</p>
        </div>

        <div class="main-panel">
            <div class="upload-section" onclick="document.getElementById('csvFile').click()" ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                <div class="upload-icon">ğŸ“</div>
                <h3>CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</h3>
                <p>ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ</p>
                <small>Aåˆ—ã«æ¤œç´¢ã—ãŸã„æ–‡å­—åˆ—ãŒå…¥ã£ãŸCSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</small>
                <div style="margin-top: 15px; padding: 10px; background: rgba(40, 167, 69, 0.1); border-radius: 8px; color: #155724;">
                    ğŸ’¾ <strong>ä¿å­˜å…ˆ:</strong> ã€Œç”»åƒä¿å­˜å…ˆã€ãƒ•ã‚©ãƒ«ãƒ€ã«è‡ªå‹•ä¿å­˜ã•ã‚Œã¾ã™
                </div>
            </div>
            <input type="file" id="csvFile" class="file-input" accept=".csv" onchange="handleCSVUpload(event)">

            <div class="csv-preview" id="csvPreview">
                <h3>ğŸ“Š CSVãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h3>
                <div id="csvTable"></div>
                <p style="margin-top: 15px; color: #6c757d;">
                    <strong>æ¤œå‡ºã•ã‚ŒãŸã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ•°:</strong> <span id="keywordCount">0</span>
                </p>
            </div>

            <div class="settings-grid">
                <div class="setting-item">
                    <div class="setting-label">ğŸ” æ¤œç´¢ã‚¨ãƒ³ã‚¸ãƒ³</div>
                    <select class="form-select" id="searchEngine">
                        <option value="unsplash">Unsplash (é«˜å“è³ªå†™çœŸ)</option>
                        <option value="pixabay">Pixabay (ç„¡æ–™ç”»åƒ)</option>
                        <option value="pexels">Pexels (ãƒ—ãƒ­å“è³ª)</option>
                    </select>
                </div>

                <div class="setting-item">
                    <div class="setting-label">ğŸ“ ç”»åƒã‚µã‚¤ã‚º</div>
                    <select class="form-select" id="imageSize">
                        <option value="small">å° (640x640)</option>
                        <option value="medium" selected>ä¸­ (1280x1280)</option>
                        <option value="large">å¤§ (1920x1920)</option>
                    </select>
                </div>

                <div class="setting-item">
                    <div class="setting-label">â±ï¸ æ¤œç´¢é–“éš” (ç§’)</div>
                    <input type="number" class="form-input" id="searchDelay" value="2" min="1" max="10">
                </div>

                <div class="setting-item">
                    <div class="setting-label">ğŸ“¸ æœ€å¤§å–å¾—æ•°/ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰</div>
                    <input type="number" class="form-input" id="maxImages" value="1" min="1" max="5">
                </div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button class="btn btn-success" id="startBtn" onclick="startImageSearch()" disabled>
                    ğŸš€ ç”»åƒæ¤œç´¢é–‹å§‹
                </button>
                <button class="btn btn-danger" id="stopBtn" onclick="stopImageSearch()" style="display: none;">
                    â¹ï¸ åœæ­¢
                </button>
            </div>
        </div>

        <div class="progress-section" id="progressSection">
            <h3>ğŸ“ˆ é€²æ—çŠ¶æ³</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">æº–å‚™ä¸­...</div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number" id="totalKeywords">0</div>
                    <div class="stat-label">ç·ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ•°</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="processedKeywords">0</div>
                    <div class="stat-label">å‡¦ç†æ¸ˆã¿</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="successfulDownloads">0</div>
                    <div class="stat-label">æˆåŠŸãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="errorCount">0</div>
                    <div class="stat-label">ã‚¨ãƒ©ãƒ¼æ•°</div>
                </div>
            </div>

            <div class="log-section" id="logSection">
                <div class="log-entry log-info">ğŸ“‹ ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™...</div>
            </div>
        </div>

        <div class="results-section" id="resultsSection">
            <h3>ğŸ–¼ï¸ æ¤œç´¢çµæœ</h3>
            <div class="results-grid" id="resultsGrid"></div>
        </div>
    </div>

    <script>
        class ImageSearcher {
            constructor() {
                this.csvData = [];
                this.keywords = [];
                this.currentIndex = 0;
                this.isProcessing = false;
                this.results = [];
                this.stats = {
                    total: 0,
                    processed: 0,
                    successful: 0,
                    errors: 0
                };
            }

            // CSVå‡¦ç†
            parseCSV(csvText) {
                const lines = csvText.split('\n').filter(line => line.trim());
                const data = [];
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line) {
                        const columns = this.parseCSVLine(line);
                        if (columns.length > 0 && columns[0].trim()) {
                            data.push(columns);
                        }
                    }
                }
                
                return data;
            }

            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                result.push(current);
                return result.map(item => item.replace(/^"|"$/g, '').trim());
            }

            // CSVè¡¨ç¤º
            displayCSVPreview() {
                const preview = document.getElementById('csvPreview');
                const tableContainer = document.getElementById('csvTable');
                
                if (this.csvData.length === 0) {
                    preview.style.display = 'none';
                    return;
                }

                let tableHTML = '<table class="csv-table"><thead><tr>';
                
                // ãƒ˜ãƒƒãƒ€ãƒ¼ä½œæˆ
                const maxColumns = Math.max(...this.csvData.map(row => row.length));
                for (let i = 0; i < maxColumns; i++) {
                    tableHTML += `<th>${String.fromCharCode(65 + i)}åˆ—</th>`;
                }
                tableHTML += '</tr></thead><tbody>';

                // ãƒ‡ãƒ¼ã‚¿è¡Œä½œæˆï¼ˆæœ€åˆã®10è¡Œã¾ã§è¡¨ç¤ºï¼‰
                const displayRows = Math.min(10, this.csvData.length);
                for (let i = 0; i < displayRows; i++) {
                    tableHTML += '<tr>';
                    for (let j = 0; j < maxColumns; j++) {
                        const cellData = this.csvData[i][j] || '';
                        const isKeyword = j === 0 && cellData.trim() !== '';
                        tableHTML += `<td style="${isKeyword ? 'background: rgba(102, 126, 234, 0.2); font-weight: bold;' : ''}">${cellData}</td>`;
                    }
                    tableHTML += '</tr>';
                }
                
                if (this.csvData.length > 10) {
                    tableHTML += `<tr><td colspan="${maxColumns}" style="text-align: center; color: #6c757d; font-style: italic;">... ä»– ${this.csvData.length - 10} è¡Œ</td></tr>`;
                }
                
                tableHTML += '</tbody></table>';
                tableContainer.innerHTML = tableHTML;
                
                // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡º
                this.keywords = this.csvData
                    .map(row => row[0])
                    .filter(keyword => keyword && keyword.trim() !== '')
                    .map(keyword => keyword.trim());
                
                document.getElementById('keywordCount').textContent = this.keywords.length;
                document.getElementById('startBtn').disabled = this.keywords.length === 0;
                
                preview.style.display = 'block';
                preview.classList.add('fade-in');
            }

            // ç”»åƒæ¤œç´¢
            async searchImages(keyword, engine, size, maxCount) {
                this.addLog(`ğŸ” "${keyword}" ã‚’æ¤œç´¢ä¸­...`, 'info');
                
                try {
                    let images = [];
                    
                    if (engine === 'unsplash') {
                        images = await this.searchUnsplash(keyword, size, maxCount);
                    } else if (engine === 'pixabay') {
                        images = await this.searchPixabay(keyword, size, maxCount);
                    } else if (engine === 'pexels') {
                        images = await this.searchPexels(keyword, size, maxCount);
                    }
                    
                    if (images.length > 0) {
                        this.addLog(`âœ… "${keyword}" ã®ç”»åƒ ${images.length} ä»¶ã‚’å–å¾—`, 'success');
                    } else {
                        // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¨ã—ã¦ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ç”»åƒã‚’ä½¿ç”¨
                        images = await this.getPlaceholderImages(keyword, size, maxCount);
                        this.addLog(`âš ï¸ "${keyword}" ã®æ¤œç´¢çµæœãŒè¦‹ã¤ã‹ã‚‰ãªã„ãŸã‚ã€ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ç”»åƒã‚’ä½¿ç”¨`, 'warning');
                    }
                    
                    return images;
                } catch (error) {
                    this.addLog(`âŒ "${keyword}" ã®æ¤œç´¢ã«å¤±æ•—: ${error.message}`, 'error');
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ç”»åƒã‚’è¿”ã™
                    return await this.getPlaceholderImages(keyword, size, maxCount);
                }
            }

            // Unsplashæ¤œç´¢ï¼ˆç„¡æ–™ãƒ—ãƒ©ãƒ³ã®åˆ¶é™ã«æ³¨æ„ï¼‰
            async searchUnsplash(keyword, size, maxCount) {
                const images = [];
                
                // ç„¡æ–™ã‚¢ã‚¯ã‚»ã‚¹ã®ãŸã‚ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’ä½¿ç”¨
                for (let i = 0; i < maxCount; i++) {
                    const width = size === 'small' ? 640 : size === 'medium' ? 1280 : 1920;
                    const height = width;
                    const imageUrl = `https://source.unsplash.com/${width}x${height}/?${encodeURIComponent(keyword)}&${Date.now()}-${i}`;
                    
                    images.push({
                        url: imageUrl,
                        filename: `${this.sanitizeFilename(keyword)}_unsplash_${i + 1}.jpg`,
                        size: size
                    });
                }
                
                return images;
            }

            // Pixabayæ¤œç´¢ï¼ˆãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å®Ÿè£…ï¼‰
            async searchPixabay(keyword, size, maxCount) {
                return await this.getPlaceholderImages(keyword, size, maxCount, 'pixabay');
            }

            // Pexelsæ¤œç´¢ï¼ˆãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å®Ÿè£…ï¼‰
            async searchPexels(keyword, size, maxCount) {
                return await this.getPlaceholderImages(keyword, size, maxCount, 'pexels');
            }

            // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ç”»åƒå–å¾—
            async getPlaceholderImages(keyword, size, maxCount, source = 'picsum') {
                const images = [];
                
                for (let i = 0; i < maxCount; i++) {
                    const width = size === 'small' ? 640 : size === 'medium' ? 1280 : 1920;
                    const height = width;
                    const imageUrl = `https://picsum.photos/${width}/${height}?random=${Date.now()}-${i}&keyword=${encodeURIComponent(keyword)}`;
                    
                    images.push({
                        url: imageUrl,
                        filename: `${this.sanitizeFilename(keyword)}_${source}_${i + 1}.jpg`,
                        size: size
                    });
                }
                
                return images;
            }

            // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ã‚µãƒ‹ã‚¿ã‚¤ã‚º
            sanitizeFilename(filename) {
                return filename
                    .replace(/[<>:"/\\|?*]/g, '_')  // ç„¡åŠ¹ãªæ–‡å­—ã‚’ç½®æ›
                    .replace(/\s+/g, '_')           // ã‚¹ãƒšãƒ¼ã‚¹ã‚’ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã«
                    .replace(/[^\w\-_.]/g, '_')     // è‹±æ•°å­—ã€ãƒã‚¤ãƒ•ãƒ³ã€ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã€ãƒ”ãƒªã‚ªãƒ‰ä»¥å¤–ã‚’ç½®æ›
                    .substring(0, 50);              // é•·ã•åˆ¶é™
            }

            // ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            async downloadImage(imageData, keyword) {
                try {
                    this.addLog(`ğŸ’¾ "${imageData.filename}" ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­...`, 'info');
                    
                    // å®Ÿéš›ã«ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                    const response = await fetch(imageData.url);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const blob = await response.blob();
                    
                    // ç”»åƒä¿å­˜å…ˆãƒ•ã‚©ãƒ«ãƒ€ã«ä¿å­˜
                    this.saveFile(blob, imageData.filename);
                    
                    this.addLog(`âœ… "${imageData.filename}" ã‚’ç”»åƒä¿å­˜å…ˆãƒ•ã‚©ãƒ«ãƒ€ã«ä¿å­˜å®Œäº†`, 'success');
                    
                    return {
                        keyword: keyword,
                        filename: imageData.filename,
                        url: imageData.url,
                        status: 'success'
                    };
                } catch (error) {
                    this.addLog(`âŒ "${imageData.filename}" ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—: ${error.message}`, 'error');
                    throw error;
                }
            }

            // ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ï¼ˆã€Œç”»åƒä¿å­˜å…ˆã€ãƒ•ã‚©ãƒ«ãƒ€ã«ä¿å­˜ï¼‰
            saveFile(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ç”»åƒä¿å­˜å…ˆ/${filename}`;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // ãƒ¡ã‚¤ãƒ³å‡¦ç†
            async startProcessing() {
                if (this.isProcessing || this.keywords.length === 0) return;
                
                this.isProcessing = true;
                this.currentIndex = 0;
                this.results = [];
                this.stats = {
                    total: this.keywords.length,
                    processed: 0,
                    successful: 0,
                    errors: 0
                };
                
                this.showProgressSection();
                this.updateStats();
                this.updateProgress();
                
                const engine = document.getElementById('searchEngine').value;
                const size = document.getElementById('imageSize').value;
                const maxImages = parseInt(document.getElementById('maxImages').value);
                const delay = parseInt(document.getElementById('searchDelay').value) * 1000;
                
                this.addLog(`ğŸš€ å‡¦ç†é–‹å§‹: ${this.keywords.length} ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰`, 'info');
                
                for (let i = 0; i < this.keywords.length && this.isProcessing; i++) {
                    const keyword = this.keywords[i];
                    this.currentIndex = i;
                    
                    try {
                        this.updateProgress();
                        
                        // ç”»åƒæ¤œç´¢
                        const images = await this.searchImages(keyword, engine, size, maxImages);
                        
                        // ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                        for (const imageData of images) {
                            if (!this.isProcessing) break;
                            
                            try {
                                const result = await this.downloadImage(imageData, keyword);
                                this.results.push(result);
                                this.stats.successful++;
                            } catch (error) {
                                this.results.push({
                                    keyword: keyword,
                                    filename: imageData.filename,
                                    url: imageData.url,
                                    status: 'error',
                                    error: error.message
                                });
                                this.stats.errors++;
                            }
                        }
                        
                        this.stats.processed++;
                        this.updateStats();
                        this.updateResults();
                        
                        // æ¬¡ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¾ã§å¾…æ©Ÿ
                        if (i < this.keywords.length - 1 && this.isProcessing) {
                            await this.delay(delay);
                        }
                        
                    } catch (error) {
                        this.addLog(`âŒ "${keyword}" ã®å‡¦ç†ã«å¤±æ•—: ${error.message}`, 'error');
                        this.stats.errors++;
                        this.stats.processed++;
                        this.updateStats();
                    }
                }
                
                if (this.isProcessing) {
                    this.addLog(`ğŸ‰ å…¨ã¦ã®å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸï¼`, 'success');
                    this.updateProgress(100);
                }
                
                this.isProcessing = false;
                this.updateUI();
            }

            stopProcessing() {
                this.isProcessing = false;
                this.addLog(`â¹ï¸ å‡¦ç†ã‚’åœæ­¢ã—ã¾ã—ãŸ`, 'warning');
                this.updateUI();
            }

            // UIæ›´æ–°
            updateProgress(customPercent = null) {
                const percent = customPercent !== null ? customPercent : 
                    this.stats.total > 0 ? Math.round((this.stats.processed / this.stats.total) * 100) : 0;
                
                document.getElementById('progressFill').style.width = `${percent}%`;
                
                if (this.isProcessing && this.currentIndex < this.keywords.length) {
                    const currentKeyword = this.keywords[this.currentIndex];
                    document.getElementById('progressText').textContent = 
                        `å‡¦ç†ä¸­: "${currentKeyword}" (${this.stats.processed + 1}/${this.stats.total})`;
                } else if (percent === 100) {
                    document.getElementById('progressText').textContent = 'å®Œäº†ï¼';
                } else {
                    document.getElementById('progressText').textContent = 'æº–å‚™ä¸­...';
                }
            }

            updateStats() {
                document.getElementById('totalKeywords').textContent = this.stats.total;
                document.getElementById('processedKeywords').textContent = this.stats.processed;
                document.getElementById('successfulDownloads').textContent = this.stats.successful;
                document.getElementById('errorCount').textContent = this.stats.errors;
            }

            updateResults() {
                const grid = document.getElementById('resultsGrid');
                const resultsSection = document.getElementById('resultsSection');
                
                if (this.results.length === 0) {
                    resultsSection.style.display = 'none';
                    return;
                }
                
                grid.innerHTML = this.results.map(result => `
                    <div class="result-item">
                        ${result.status === 'success' ? 
                            `<img src="${result.url}" alt="${result.keyword}" class="result-image" loading="lazy">` :
                            `<div class="result-image" style="background: #f8f9fa; display: flex; align-items: center; justify-content: center; color: #6c757d;">âŒ ã‚¨ãƒ©ãƒ¼</div>`
                        }
                        <div class="result-name">${result.keyword}</div>
                        <div class="result-status ${result.status === 'success' ? 'status-success' : 'status-error'}">
                            ${result.status === 'success' ? 'âœ… æˆåŠŸ' : 'âŒ å¤±æ•—'}
                        </div>
                    </div>
                `).join('');
                
                resultsSection.style.display = 'block';
            }

            updateUI() {
                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                
                if (this.isProcessing) {
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-flex';
                } else {
                    startBtn.style.display = 'inline-flex';
                    stopBtn.style.display = 'none';
                }
            }

            showProgressSection() {
                const section = document.getElementById('progressSection');
                section.style.display = 'block';
                section.classList.add('fade-in');
            }

            addLog(message, type = 'info') {
                const logSection = document.getElementById('logSection');
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.textContent = `[${timestamp}] ${message}`;
                
                logSection.appendChild(logEntry);
                logSection.scrollTop = logSection.scrollHeight;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let imageSearcher;

        // åˆæœŸåŒ–
        window.addEventListener('load', () => {
            imageSearcher = new ImageSearcher();
        });

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        function handleCSVUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // è¤‡æ•°ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§è©¦è¡Œ
            tryReadWithEncoding(file, 'UTF-8')
                .then(result => {
                    if (isValidText(result)) {
                        processCSVContent(result);
                    } else {
                        return tryReadWithEncoding(file, 'Shift_JIS');
                    }
                })
                .then(result => {
                    if (result && isValidText(result)) {
                        processCSVContent(result);
                    } else {
                        return tryReadWithEncoding(file, 'UTF-16');
                    }
                })
                .then(result => {
                    if (result && isValidText(result)) {
                        processCSVContent(result);
                    } else {
                        // æœ€å¾Œã®æ‰‹æ®µã¨ã—ã¦ã€ãƒã‚¤ãƒŠãƒªã§èª­ã¿è¾¼ã‚“ã§æ¨æ¸¬
                        return readAsArrayBuffer(file);
                    }
                })
                .catch(error => {
                    alert('CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                    console.error(error);
                });
        }

        function tryReadWithEncoding(file, encoding) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    resolve(e.target.result);
                };
                reader.onerror = reject;
                
                if (encoding === 'UTF-8') {
                    reader.readAsText(file, 'UTF-8');
                } else if (encoding === 'Shift_JIS') {
                    // Shift_JISã®ä»£æ›¿ã¨ã—ã¦ã€latin1ã§èª­ã¿è¾¼ã‚“ã§å¤‰æ›ã‚’è©¦è¡Œ
                    reader.readAsText(file, 'shift_jis');
                } else if (encoding === 'UTF-16') {
                    reader.readAsText(file, 'UTF-16');
                }
            });
        }

        function readAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const arrayBuffer = e.target.result;
                    const bytes = new Uint8Array(arrayBuffer);
                    
                    // BOMã‚’ãƒã‚§ãƒƒã‚¯
                    if (bytes.length >= 3 && bytes[0] === 0xEF && bytes[1] === 0xBB && bytes[2] === 0xBF) {
                        // UTF-8 BOM
                        const decoder = new TextDecoder('utf-8');
                        resolve(decoder.decode(bytes.slice(3)));
                    } else if (bytes.length >= 2 && bytes[0] === 0xFF && bytes[1] === 0xFE) {
                        // UTF-16 LE BOM
                        const decoder = new TextDecoder('utf-16le');
                        resolve(decoder.decode(bytes.slice(2)));
                    } else if (bytes.length >= 2 && bytes[0] === 0xFE && bytes[1] === 0xFF) {
                        // UTF-16 BE BOM
                        const decoder = new TextDecoder('utf-16be');
                        resolve(decoder.decode(bytes.slice(2)));
                    } else {
                        // BOMãªã—ã€Shift_JISã®å¯èƒ½æ€§ãŒé«˜ã„
                        try {
                            const decoder = new TextDecoder('shift_jis');
                            resolve(decoder.decode(bytes));
                        } catch (error) {
                            // UTF-8ã§ã‚‚è©¦è¡Œ
                            const decoder = new TextDecoder('utf-8', { fatal: false });
                            resolve(decoder.decode(bytes));
                        }
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        function isValidText(text) {
            // æ–‡å­—åŒ–ã‘ã—ã¦ã„ãªã„ã‹ã‚’ãƒã‚§ãƒƒã‚¯
            if (!text || typeof text !== 'string') return false;
            
            // æ¥µç«¯ã«æ–‡å­—åŒ–ã‘ã—ãŸæ–‡å­—ï¼ˆç½®æ›æ–‡å­—ãªã©ï¼‰ãŒå¤šããªã„ã‹ãƒã‚§ãƒƒã‚¯
            const replacementCharCount = (text.match(/ï¿½/g) || []).length;
            const totalLength = text.length;
            
            // ç½®æ›æ–‡å­—ãŒ10%ä»¥ä¸Šã®å ´åˆã¯æ–‡å­—åŒ–ã‘ã¨åˆ¤æ–­
            if (totalLength > 0 && (replacementCharCount / totalLength) > 0.1) {
                return false;
            }
            
            // æ—¥æœ¬èªæ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆCSVã«æ—¥æœ¬èªãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆï¼‰
            const hasJapanese = /[ã²ã‚‰ãŒãªã‚«ã‚¿ã‚«ãƒŠæ¼¢å­—]/.test(text) || /[ã‚¡-ãƒ¶ãƒ¼]/.test(text) || /[ä¸€-é¾¯]/.test(text);
            const hasBasicText = /[a-zA-Z0-9,\r\n]/.test(text);
            
            return hasJapanese || hasBasicText;
        }

        function processCSVContent(content) {
            try {
                imageSearcher.csvData = imageSearcher.parseCSV(content);
                imageSearcher.displayCSVPreview();
                imageSearcher.addLog(`ğŸ“„ CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ­£å¸¸ã«èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼ˆ${imageSearcher.csvData.length}è¡Œï¼‰`, 'success');
            } catch (error) {
                alert('CSVãƒ•ã‚¡ã‚¤ãƒ«ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                console.error(error);
            }
        }

        function startImageSearch() {
            imageSearcher.startProcessing();
        }

        function stopImageSearch() {
            imageSearcher.stopProcessing();
        }

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.currentTarget.classList.remove('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0 && files[0].name.endsWith('.csv')) {
                const fakeEvent = { target: { files: [files[0]] } };
                handleCSVUpload(fakeEvent);
            }
        }

        // ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æ¤œå‡ºã‚’æ”¹å–„ã™ã‚‹è¿½åŠ ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function detectEncoding(bytes) {
            // BOMãƒã‚§ãƒƒã‚¯
            if (bytes.length >= 3 && bytes[0] === 0xEF && bytes[1] === 0xBB && bytes[2] === 0xBF) {
                return { encoding: 'utf-8', bomLength: 3 };
            }
            if (bytes.length >= 2 && bytes[0] === 0xFF && bytes[1] === 0xFE) {
                return { encoding: 'utf-16le', bomLength: 2 };
            }
            if (bytes.length >= 2 && bytes[0] === 0xFE && bytes[1] === 0xFF) {
                return { encoding: 'utf-16be', bomLength: 2 };
            }
            
            // æ—¥æœ¬èªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®æ¨æ¸¬
            let asciiCount = 0;
            let utf8Count = 0;
            let sjisCount = 0;
            
            for (let i = 0; i < Math.min(bytes.length, 1000); i++) {
                const byte = bytes[i];
                
                // ASCIIç¯„å›²
                if (byte < 0x80) {
                    asciiCount++;
                } 
                // UTF-8ãƒãƒ«ãƒãƒã‚¤ãƒˆ
                else if (byte >= 0xC0 && byte <= 0xDF && i + 1 < bytes.length) {
                    const next = bytes[i + 1];
                    if (next >= 0x80 && next <= 0xBF) {
                        utf8Count++;
                        i++; // æ¬¡ã®ãƒã‚¤ãƒˆã‚’ã‚¹ã‚­ãƒƒãƒ—
                    }
                }
                // Shift_JISå…¨è§’æ–‡å­—
                else if ((byte >= 0x81 && byte <= 0x9F) || (byte >= 0xE0 && byte <= 0xFC)) {
                    sjisCount++;
                }
            }
            
            // æ¨æ¸¬çµæœ
            if (utf8Count > sjisCount) {
                return { encoding: 'utf-8', bomLength: 0 };
            } else if (sjisCount > 0) {
                return { encoding: 'shift_jis', bomLength: 0 };
            } else {
                return { encoding: 'utf-8', bomLength: 0 };
            }
        }
    </script>
</body>
</html>